# 分治法：
* 算法介绍：
* 代表案例：汉诺塔

# 贪心算法：
* 算法介绍：
* 代表案例：
 
# 动态规划：
* 算法介绍：  
  * （1）动态规划（Dynamic Programming）算法的核心思想是：**将大问题划分为小问题**进行解决，
    从而一步步**获取最优解**的处理算法  
  * （2）动态规划算法与分治算法类似，其基本思想也是将带求解问题分解成若干个子问题，先求解子问题，
    然后从这些子问题的解得到原问题的解  
  * （3）与分治算法不同的时，**适合于动态规划求解的问题，经分解得到的子问题往往不是相互独立的**，
     即**下一个子阶段的求解是建立在上一个子阶段的解的基础上**，进行进一步的求解    
  * （4）动态规划可以通过填表的方式来逐步推进，得到最优解
  * （5）动态规划每一个子阶段获得的解都是该阶段的最优解
  
* 动态规划问题求解基本步骤
  * 动态规划所处理的问题是一个多阶段决策问题。一般由初始状态开始。
    通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列。
    同一时候确定了完毕整个过程的一条活动路线(一般是求最优的活动路线)。
    动态规划的设计都有着一定的模式。一般要经历下面几个步骤。
  * 初始状态→│决策1│→│决策2│→…→│决策n│→结束状态
  *（1）**划分阶段**：依照问题的时间或空间特征。把问题分为若干个阶段。
    在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的。否则问题就无法求解。
  *（2）**确定状态和状态变量**：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。
    当然，状态的选择要满足无后效性。
  *（3）**确定决策并写出状态转移方程**：由于决策和状态转移有着天然的联系，
       状态转移就是依据上一阶段的状态和决策来导出本阶段的状态。所以假设确定了决策。
       状态转移方程也就可写出。但其实经常是反过来做。依据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。
  *（4）**寻找边界条件**：给出的状态转移方程是一个递推式。须要一个递推的终止条件或边界条件。
  * 一般，仅仅要解决这个问题的阶段、状态和状态转移决策确定了。就能够写出状态转移方程（包含边界条件）。
  * 实际应用中能够按下面几个简化的步骤进行设计：
   *（1）分析最优解的性质。并刻画其结构特征。
   *（2）递归的定义最优解。
   *（3）以自底向上或自顶向下的记忆化方式计算出最优值。
   *（4）依据计算最优值时得到的信息，构造问题的最优解。  
* 代表案例:0-1背包问题
  * 具体描述：有一个背包，容量为4磅，现有如下物品：
  
  物品     |  重量  |  价格
  --------|-------|----------
  吉他     |  1    |  1500
  音响     |  4    |  3000
  电脑     |  3    |  2000
  
  * 要求：
    * 1.要求达到的目的为装入的背包的物品总价值最大，并且重量不能超出背包容量
    * 2.要求装入的物品不能重复
  * 解法：
    * 每次遍历得到第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中；
      对于给定的第n个物品，其中w[i]代表第i个物品的重量，v[i]代表第i个物品的价值，代表背包的容量；
      再令v[i][j]表示在前i个物品中能够装入容量为j的背包中最大价值
    * （1）v[i][0] = v[0][j] = 0; 
       // 没有物品或者背包容量为0时，背包中可以放入物品最大价值为0
       
    * （2）当w[i] > j时，v[i][j] = v[i-1][j];
       // 当新增加的第i个物品的重量大于背包的容量j时，说明该物品不能放入背包中，
          背包中应当放入的物品和背包容量为j-1时相同
       
    * （3）当w[i] <= j时，v[i][j] = max(v[i-1][j], v[i-1][j-w[i]] + v[i]);
       // 当新增加的第i个物品的重量小于等于背包的容量j时，就需要判断是新放入第i个物品后背包中物品总价值最大，
          还是不放入第i个物品背包中物品总价值最大
    * 表格如下：由于物品个数为3，背包容量为4，所以i为3，j为4
    
    索引  |  0   |   1   |     2    |   3   |  4
    -----|------|---------|---------|-------|--------
    0    | 0    |   0    |    0    |   0   |  0
    1    | 0    |  1500  |   1500  |  1500 | 1500       
    2    | 0    |  1500  |   1500  |  1500 | 3000       
    3    | 0    |  1500  |   1500  |  2000 | 3500       
    
    * 扩展：如果我们希望知道背包中放入了哪些物品，就需要在放入物品时用一个二维数组path保存，
      最后通过倒序遍历path数组来获取结果
    ```java
    /**
     * 0-1背包：动态规划问题
     * 时间复杂度：O(n*m)： 遍历数组v
     * 空间复杂度：O(n*m)： 数组int[][] v = new int[n+1][m+1]
     * n为物品个数，m为背包容量
     * @author NiuQun
     * @date 2021/11/3
     */
    public class KnapsackProblem {
        public static void main(String[] args) {
            // 数组w存储每个物品的重量
            int[] w = {1, 4, 3};
    
            // 数组val存储每个物品对应的价值
            int[] val = {1500, 3000, 2000};
    
            // n表示物品的个数
            int n = val.length;
    
            // m表示背包的容量
            int m = 4;
    
            // 数组v存储当可以放入第i个物品且背包容量为j时，背包中可以放入的物品的最大价值
            // 其中i代表第i个物品，j代表第i个物品的重量，同时i为行索引，j为列索引
            int[][] v = new int[n+1][m+1];
            int[][] path = new int[n+1][m+1];
            for (int i = 0; i <= n; i++) {
                for (int j = 0; j <= m; j++) {
                    if (i == 0 || j == 0) {
                        v[i][j] = 0;
                    } else {
                        // 如果新增物品的重量 > 背包容量，则放入情况和没有新增该物品时一样
                        if (w[i-1] > j) {
                            v[i][j] = v[i-1][j];
    
                        } else {
                            // 如果新增物品的重量 <= 背包容量
                            // v[i][j] = Math.max(v[i-1][j], v[i-1][j-w[i-1]] + val[i-1]);
                            // 这里如果我们想要知道每次增加物品i时，是否需要将物品i放入背包中，我们需要将上述语句改成if-else语句
    
                            // 如果将新增物品放入背包后，背包中物品总价值小于等于不放入物品i时的总价值
                            if (v[i-1][j] > v[i-1][j-w[i-1]] + val[i-1]) {
                                // 则说明新增物品i不应当放入背包，使得背包中商品总价值最大
                                v[i][j] = v[i-1][j];
                            } else {
                                // 如果将新增物品放入背包后，背包中物品总价值大于不放入物品i时的总价值
                                // 则说明新增物品i应当放入背包，使得背包中商品总价值最大
                                v[i][j] = v[i-1][j-w[i-1]] + val[i-1];
                                path[i][j] = 1;
                            }
                        }
                    }
                }
            }
            for (int[] value : v) {
                System.out.println(Arrays.toString(value));
            }
            System.out.println("简单打印path数组会得到所有的冗余情况：");
            for (int[] temp : path) {
                System.out.println(Arrays.toString(temp));
            }
            System.out.println("但是实际上只需要最后的放入情况，我们应当倒序遍历数组path：");
            int i = n;
            int j = m;
            while (i > 0 && j > 0) {
                if (path[i][j] == 1) {
                    System.out.printf("第%d个商品放入到背包中\n", i);
                    // 同时背包容量需要减去当前物品的重量，因为这里需要和之前我们向path数组中存放1时做相反的操作
                    // 背包的剩余容量为当前容量减去物品i的容量
                    j = j - w[i - 1];
                }
                i--;
            }
            System.out.println("当然我们也可以通过直接倒序遍历数组v来获取哪些物品放入了背包：");
    
            i = n;
            j = m;
            while (i > 0 && j > 0) {
                // 当新增物品i时背包中物品总价值>新增物品i-1时背包中物品总价值
                // 说明将新增物品i放入了背包使得背包中物品总价值最大
                if (v[i][j] > v[i-1][j]) {
                    System.out.printf("第%d个商品放入到背包中\n", i);
                    // 背包的剩余容量为当前容量减去物品i的容量
                    j = j - w[i-1];
                }
                i--;
            }
        }
    }
    ```
    
    * 提升空间复杂度：由于求v[i][j]时我们只用到v[i-1][xxx]这一行数据，
      那么我们实际上可以定义一个一位数组v[j],不断的刷新该数组中的值，
      即当i=1时保存背包容量为1-j的情况，当i=2是覆盖i=1时的数组内容，
      这样就达到了减小空间复杂度的目标, 但是缺点无法知道背包中具体放入了哪些物品
    ```java
    /**
     * 0-1背包：动态规划问题
     * 时间复杂度：O(n*m)
     * 空间复杂度：O(m)
     * n为物品个数，m为背包容量
     * @author NiuQun
     * @date 2021/11/4
     */
    public class KnapsackProblem1 {
        public static void main(String[] args) {
            // 数组w存储每个物品的重量
            int[] w = {1, 4, 3};
    
            // 数组val存储每个物品对应的价值
            int[] val = {1500, 3000, 2000};
    
            // n表示物品的个数
            int n = val.length;
    
            // m表示背包的容量
            int m = 4;
    
            // v[i]代表背包容量为j时且新增物品i时，背包中物品的最大总价值
            int[] v = new int[m+1];
    
            for (int i = 1; i <= n; i++) {
                // 新增物品i时
                for (int j = m; j > 0; j--) {
                    // 如果背包容量 > 新增物品的重量,则代表新增物品i可以尝试放入背包
                    if (j >= w[i-1]) {
                        // 数组v中原本保存的是新增物品i-1且背包容量为0~m时背包中物品总价值最大值
                        // 由于之前使用二维数组，在更改v[i][j]时，我们实际上用到的用于比较的数据是v[i-1][0] ~ v[i-1][j],
                        // 对于v[i-1][j+1] ~ v[i-1][m]中的数据并没有用到，所以这里可以采用一位数组减小空间复杂度
                        // w[i-1]代表物品i的重量，val[i-1]代表物品i的价值
                        v[j] = Math.max(v[j], v[j-w[i-1]] + val[i-1]);
                    }
                    // 如果背包容量 < 新增物品的重量,则代表新增物品i可以无法放入背包，情况与新增物品i-1时相同
                }
            }
            /*
            // 上述for循环可以稍微优化一下
            for (int i = 1; i <= n; i++) {
                // 背包容量小于等于新增物品i质量时，情况和新增物品i-1时情况一致，不需要再修改数组
                for (int j = m; j > w[i-1]; j--) {
                    v[j] = Math.max(v[j], v[j-w[i-1]] + val[i-1]);
                }
            }
             */
            System.out.println(v[m]);
        }
    }

    ```

* 代表案例：完全背包
  * 具体描述：设有n种物品，每种物品有1个重量即1个价值，但每种物品的数量是无线的。同时有一个背包，
    背包的最大载重量为M，现在从n种物品中选取若干件（同一种物品可以多次选取），使其在重量之和不超过
    背包容量的情况下，使得背包中的物品的总价值最大
  * 输入：
    * 第1行：2个整数，M(背包容量， M<=200)和N(物品数量， N<=30)  
    * 第2...N+1行：每行2个整数Wi，Vi，表示每个物品的重量和价值
  * 输出：
    * 仅一行，一个数，表示最大总价值  
  * 输入样例：  
    10, 4    
    2, 1  
    3, 3  
    4, 5  
    7, 9  
  * 输出样例：  
    12

  * 解法1：暴力解法    
    * 每件物品的数量取值范围为[0, M/Wi],那么每次就可以看做是增加M/Wi个第i件物品，
      就可以将完全背包转换成0-1背包
    ```java
    public class KnapsackProblem2 {
        public static void main(String[] args) {
            // 每个物品的价值
            int[] val = {1, 3, 5, 9};
            // 每个物品的重量
            int[] w = {2, 3, 4, 7};
            // 物品的个数
            int n = 4;
            // 背包的最大容量
            int m = 10;
    
            int[] v = new int[m+1];
    
            for (int i = 1; i <= n; i++) {
                // 每次增加[0, j/w[i-1]个物品i可选
                for (int j = m; j >= w[i-1]; j--) {
                    for (int k = 0; k <= j / w[i - 1]; k++) {
                        v[j] = Math.max(v[j], k*val[i-1] + v[j-k*w[i-1]]);
                    }
                }
            }
            System.out.println(v[m]);
        }
    }
    ``` 
  * 解法2：
    * 每次遍历得到第i个物品，根据w[i]和v[i]来确定是否需要将该物品放入背包中；
      对于给定的无限个第n个物品，其中w[i]代表第i个物品的重量，v[i]代表第i个物品的价值，代表背包的容量；
      再令v[i][j]表示在前i个物品中能够装入容量为j的背包中最大价值
    * （1）v[i][0] = v[0][j] = 0; 
       // 没有物品或者背包容量为0时，背包中可以放入物品最大价值为0
       
    * （2）当w[i] > j时，v[i][j] = v[i-1][j];
       // 当新增加的第i个物品的重量大于背包的容量j时，说明该物品不能放入背包中，
          背包中应当放入的物品和背包容量为j-1时相同
       
    * （3）当w[i] <= j时，v[i][j] = max(v[i-1][j], v[i][j-w[i-1]] + val[i-1]);
       // 当新增加的第i个物品的重量小于等于背包的容量j时，就需要判断是新放入某些个第i个物品后背包中物品总价值最大，
          还是不放入第i个物品背包中物品总价值最大
       // 对于放入某些个第i个物品的情况，假设先放入1个第i个物品，那么背包剩下的容量就是j-w[i-1], 
          就转化为求背包容量为j-w[i-1]容量的背包在可以放入某些个第i件物品的情况下，背包装入物品的最大总价值
          
    ```java
    /**
     * 完全背包：和本条数据相比较， 0-1背包是和上一条数据相比较
     * @author NiuQun
     * @date 2021/11/4
     */
    public class KnapsackProblem3 {
        public static void main(String[] args) {
            // 每个物品的价值
            int[] val = {1, 3, 5, 9};
            // 每个物品的重量
            int[] w = {2, 3, 4, 7};
            // 物品的个数
            int n = 4;
            // 背包的最大容量
            int m = 10;
    
            int[][] v = new int[n+1][m+1];
    
            for (int i = 0; i <= n; i++) {
                // 新增若干个物品i
                for (int j = 0; j <= m; j++) {
                    // 背包容量为j
                    if (i == 0 || j == 0) {
                        v[i][j] = 0;
                    } else {
                        // 当背包的容量 >= 当前物品的质量时，可以尝试放入1个物品i
                        if (j >= w[i-1]) {
                            v[i][j] = Math.max(v[i-1][j], v[i][j-w[i-1]] + val[i-1]);
                        } else {
                            // 当背包的容量 < 当前物品的质量时，无法放入当前物品，情况和i-1时一致
                            v[i][j] = v[i-1][j];
                        }
                    }
                }
            }
            System.out.println(v[n][m]);
            int i = n;
            int j = m;
            while (i > 0 && j > 0) {
                if (v[i][j] > v[i-1][j] && j >= w[i-1]) {
                    System.out.printf("放入第%d个商品到背包中\n", i);
                    j = j - w[i-1];
                } else {
                    i--;
                }
            }
    
        }
    }

    ```      
    ```java 
    /**
     * 完全背包：和本条数据相比较， 0-1背包是和上一条数据相比较
     * 使用一位数组简化空间复杂度
     * @author NiuQun
     * @date 2021/11/4
     */
    public class KnapsackProblem4 {
        public static void main(String[] args) {
            // 每个物品的价值
            int[] val = {1, 3, 5, 9};
            // 每个物品的重量
            int[] w = {2, 3, 4, 7};
            // 物品的个数
            int n = 4;
            // 背包的最大容量
            int m = 10;
    
            int[] v = new int[m + 1];
    
            for (int i = 1; i <= n; i++) {
                // 新增若干个物品i
                // 完全背包需要顺序推导，用到的是增加了物品i时的新数据
                for (int j = 1; j <= m; j++) {
                    // 如果背包装得下至少1个物品i，就可以不断尝试装入多个物品i
                    if (j >= w[i-1]) {
                        v[j] = Math.max(v[j], v[j-w[i-1]] + val[i-1]);
                    }
                }
            }
            /*
            // 可以简化为：
            for (int i = 1; i <= n; i++) {
                // 新增若干个物品i
                // 完全背包需要顺序推导，用到的是增加了物品i时的新数据
                for (int j = w[i-1]; j <= m; j++) {
                    // 如果背包装得下至少1个物品i，就可以不断尝试装入多个物品i
                    v[j] = Math.max(v[j], v[j-w[i-1]] + val[i-1]);
                }
            }
             */
            System.out.println(v[m]);
    
        }
    }
    ```
    
* 代表案例：多重背包
  * 问题描述：有N种物品和一个容量为M的背包。第i种物品最多有s[i-1]件可用，每件重量是w[i-1],价值是w[i-1]。
    求将哪些物品装入背包可以使这些物品总质量不超过背包容量且背包中物品的总价值最大
  * 问题分析：0-1背包是每种物品只有1件，完全背包是每种物品无限件，多重背包是每种物品有限件  

* 代表案例：二维费用背包：是0-1背包的变种，是0-1背包增加一个条件所得
  * 问题描述：有N件物品和一个容量是V的背包。背包能承受的最大重量是M，每件物品只能用一次，物品i的体积是ai，
    重量是bi，价值是wi。求解将哪些物品装入背包，可以使得物品总体积不超过背包容量，
    总重量不超过背包可以承受的最大重量（必须同时满足2种要求），且价值总和最大。
    
    
* 总结：
  * 0-1背包：n为物品种类数，m为背包容量
     * 二维数组解法：可以获取背包中装入了哪些物品，时间复杂度O(n*m) 空间复杂度O(n*m)
     * 滚动数组解法（内部逆序）：优化空间复杂度，但是无法记录背包中装入了哪些物品,时间复杂度O(n*m) 空间复杂度O(m)
     * tip:0-1背包如果需要知道背包中装入了哪些物品，采用二维数组解法； 如果仅仅需要知道结果，则采用滚动数组解法
          
  * 完全背包：n为物品种类数，m为背包容量
     * 朴素解法：转化为0-1背包，内部加一层循环，背包中添加新增物品数量为[0, c/w[i-1]], 
       c为背包重量，w[i-1]为新增物品i的重量， 时间复杂度O(n*m*{（j/w[i]）求平均值}) 空间复杂度O(m)
     * 二维数组解法：可以获取背包中装入了哪些物品, 时间复杂度O(n*m) 空间复杂度O(n*m)
     * 滚动数组解法（内部顺序）：优化空间复杂度，但是无法记录背包中装入了哪些物品, 时间复杂度O(n*m}) 空间复杂度O(m)
     * tip:完全背包如果需要知道背包中装入了哪些物品，采用二维数组解法； 如果仅仅需要知道结果，则采用滚动数组解法     
  * 多重背包：n为物品种类数，m为背包容量
     * 二维数组解法：
     * 朴素解法：转化为0-1背包，内部加一层循环，背包中添加新增物品数量为[0, max(c/w[i-1], s[i-1])],
       c为背包重量，w[i-1]为新增物品i的重量, s[i-1]为物品i的最大数量，时间复杂度O(m∑Si), 空间复杂度O(m)
     * 优化1-二进制优化：将s[i-1]个第i种物品拆分成多种物品，时间复杂度O(m∑logSi)，空间复杂度O(m)
     * 优化2-单调队列优化：
  * 二维费用背包：
  
  
# KMP算法：
* 算法介绍：
  * KMP是一个解决模式串在文本串中是否出现过，如果出现过，找出最早出现的位置的算法
  * KMP算法利用之前判断过的信息，通过一个next数组，保存模式串中前后最长公共子序列的长度，
    每次回溯时，通过next数组找到前面匹配过的位置，省去了大量计算时间
* 代表案例：字符串匹配问题
  * 具体描述
    
    
      
      